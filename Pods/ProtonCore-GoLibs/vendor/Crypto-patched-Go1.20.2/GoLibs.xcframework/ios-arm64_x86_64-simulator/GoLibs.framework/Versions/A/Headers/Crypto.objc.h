// Objective-C API for talking to github.com/ProtonMail/gopenpgp/v2/crypto Go package.
//   gobind -lang=objc github.com/ProtonMail/gopenpgp/v2/crypto
//
// File is generated by gobind. Do not edit.

#ifndef __Crypto_H__
#define __Crypto_H__

@import Foundation;
#include "ref.h"
#include "Universe.objc.h"

#include "Armor.objc.h"
#include "Constants.objc.h"

@class CryptoAttachmentProcessor;
@class CryptoClearTextMessage;
@class CryptoEncryptSplitResult;
@class CryptoGopenPGP;
@class CryptoIdentity;
@class CryptoKey;
@class CryptoKeyRing;
@class CryptoManualAttachmentProcessor;
@class CryptoPGPMessage;
@class CryptoPGPSignature;
@class CryptoPGPSplitMessage;
@class CryptoPlainMessage;
@class CryptoPlainMessageMetadata;
@class CryptoPlainMessageReader;
@class CryptoSessionKey;
@class CryptoSignatureCollector;
@class CryptoSignatureVerificationError;
@class CryptoSigningContext;
@class CryptoVerificationContext;
@protocol CryptoMIMECallbacks;
@class CryptoMIMECallbacks;
@protocol CryptoReader;
@class CryptoReader;
@protocol CryptoWriteCloser;
@class CryptoWriteCloser;
@protocol CryptoWriter;
@class CryptoWriter;

@protocol CryptoMIMECallbacks <NSObject>
- (void)onAttachment:(NSString* _Nullable)headers data:(NSData* _Nullable)data;
- (void)onBody:(NSString* _Nullable)body mimetype:(NSString* _Nullable)mimetype;
/**
 * Encrypted headers can be in an attachment and thus be placed at the end of the mime structure.
 */
- (void)onEncryptedHeaders:(NSString* _Nullable)headers;
- (void)onError:(NSError* _Nullable)err;
- (void)onVerified:(long)verified;
@end

@protocol CryptoReader <NSObject>
- (BOOL)read:(NSData* _Nullable)b n:(long* _Nullable)n error:(NSError* _Nullable* _Nullable)error;
@end

@protocol CryptoWriteCloser <NSObject>
- (BOOL)close:(NSError* _Nullable* _Nullable)error;
- (BOOL)write:(NSData* _Nullable)b n:(long* _Nullable)n error:(NSError* _Nullable* _Nullable)error;
@end

@protocol CryptoWriter <NSObject>
- (BOOL)write:(NSData* _Nullable)b n:(long* _Nullable)n error:(NSError* _Nullable* _Nullable)error;
@end

/**
 * AttachmentProcessor keeps track of the progress of encrypting an attachment
(optimized for encrypting large files).
 */
@interface CryptoAttachmentProcessor : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
/**
 * Finish closes the attachment and returns the encrypted data.
 */
- (CryptoPGPSplitMessage* _Nullable)finish:(NSError* _Nullable* _Nullable)error;
/**
 * Process writes attachment data to be encrypted.
 */
- (void)process:(NSData* _Nullable)plainData;
@end

/**
 * A ClearTextMessage is a signed but not encrypted PGP message,
i.e. the ones beginning with -----BEGIN PGP SIGNED MESSAGE-----.
 */
@interface CryptoClearTextMessage : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
/**
 * NewClearTextMessage generates a new ClearTextMessage from data and
signature.
 */
- (nullable instancetype)init:(NSData* _Nullable)data signature:(NSData* _Nullable)signature;
/**
 * NewClearTextMessageFromArmored returns the message body and unarmored
signature from a clearsigned message.
 */
- (nullable instancetype)initFromArmored:(NSString* _Nullable)signedMessage;
@property (nonatomic) NSData* _Nullable data;
@property (nonatomic) NSData* _Nullable signature;
/**
 * GetArmored armors plaintext and signature with the PGP SIGNED MESSAGE
armoring.
 */
- (NSString* _Nonnull)getArmored:(NSError* _Nullable* _Nullable)error;
/**
 * GetBinary returns the unarmored signed data as a []byte.
 */
- (NSData* _Nullable)getBinary;
/**
 * GetBinarySignature returns the unarmored binary signature as a []byte.
 */
- (NSData* _Nullable)getBinarySignature;
/**
 * GetString returns the unarmored signed data as a string.
 */
- (NSString* _Nonnull)getString;
@end

/**
 * EncryptSplitResult is used to wrap the encryption writecloser while storing the key packet.
 */
@interface CryptoEncryptSplitResult : NSObject <goSeqRefInterface, CryptoWriteCloser, CryptoWriter> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
- (BOOL)close:(NSError* _Nullable* _Nullable)error;
/**
 * GetKeyPacket returns the Public-Key Encrypted Session Key Packets (https://datatracker.ietf.org/doc/html/rfc4880#section-5.1).
This can be retrieved only after the message has been fully written and the writer is closed.
 */
- (NSData* _Nullable)getKeyPacket:(NSError* _Nullable* _Nullable)error;
- (BOOL)write:(NSData* _Nullable)b n:(long* _Nullable)n error:(NSError* _Nullable* _Nullable)error;
@end

/**
 * GopenPGP is used as a "namespace" for many of the functions in this package.
It is a struct that keeps track of time skew between server and client.
 */
@interface CryptoGopenPGP : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
@end

/**
 * Identity contains the name and the email of a key holder.
 */
@interface CryptoIdentity : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
@property (nonatomic) NSString* _Nonnull name;
@property (nonatomic) NSString* _Nonnull email;
@end

/**
 * Key contains a single private or public key.
 */
@interface CryptoKey : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
/**
 * NewKey creates a new key from the first key in the unarmored binary data.
 */
- (nullable instancetype)init:(NSData* _Nullable)binKeys;
/**
 * NewKeyFromArmored creates a new key from the first key in an armored string.
 */
- (nullable instancetype)initFromArmored:(NSString* _Nullable)armored;
// skipped constructor Key.NewKeyFromArmoredReader with unsupported parameter or return types

// skipped constructor Key.NewKeyFromEntity with unsupported parameter or return types

// skipped constructor Key.NewKeyFromReader with unsupported parameter or return types

/**
 * Armor returns the armored key as a string with default gopenpgp headers.
 */
- (NSString* _Nonnull)armor:(NSError* _Nullable* _Nullable)error;
/**
 * ArmorWithCustomHeaders returns the armored key as a string, with
the given headers. Empty parameters are omitted from the headers.
 */
- (NSString* _Nonnull)armorWithCustomHeaders:(NSString* _Nullable)comment version:(NSString* _Nullable)version error:(NSError* _Nullable* _Nullable)error;
/**
 * CanEncrypt returns true if any of the subkeys can be used for encryption.
 */
- (BOOL)canEncrypt;
/**
 * CanVerify returns true if any of the subkeys can be used for verification.
 */
- (BOOL)canVerify;
/**
 * Check verifies if the public keys match the private key parameters by
signing and verifying.
Deprecated: all keys are now checked on parsing.
 */
- (BOOL)check:(BOOL* _Nullable)ret0_ error:(NSError* _Nullable* _Nullable)error;
- (BOOL)clearPrivateParams;
/**
 * Copy creates a deep copy of the key.
 */
- (CryptoKey* _Nullable)copy:(NSError* _Nullable* _Nullable)error;
/**
 * GetArmoredPublicKey returns the armored public keys from this keyring.
 */
- (NSString* _Nonnull)getArmoredPublicKey:(NSError* _Nullable* _Nullable)error;
/**
 * GetArmoredPublicKeyWithCustomHeaders returns the armored public key as a string, with
the given headers. Empty parameters are omitted from the headers.
 */
- (NSString* _Nonnull)getArmoredPublicKeyWithCustomHeaders:(NSString* _Nullable)comment version:(NSString* _Nullable)version error:(NSError* _Nullable* _Nullable)error;
// skipped method Key.GetEntity with unsupported parameter or return types

/**
 * GetFingerprint gets the fingerprint from the key.
 */
- (NSString* _Nonnull)getFingerprint;
/**
 * GetHexKeyID returns the key ID, hex encoded as a string.
 */
- (NSString* _Nonnull)getHexKeyID;
// skipped method Key.GetKeyID with unsupported parameter or return types

/**
 * GetPublicKey returns the unarmored public keys from this keyring.
 */
- (NSData* _Nullable)getPublicKey:(NSError* _Nullable* _Nullable)error;
// skipped method Key.GetSHA256Fingerprints with unsupported parameter or return types

/**
 * IsExpired checks whether the key is expired.
 */
- (BOOL)isExpired;
/**
 * IsLocked checks if a private key is locked.
 */
- (BOOL)isLocked:(BOOL* _Nullable)ret0_ error:(NSError* _Nullable* _Nullable)error;
/**
 * IsPrivate returns true if the key is private.
 */
- (BOOL)isPrivate;
/**
 * IsRevoked checks whether the key or the primary identity has a valid revocation signature.
 */
- (BOOL)isRevoked;
/**
 * IsUnlocked checks if a private key is unlocked.
 */
- (BOOL)isUnlocked:(BOOL* _Nullable)ret0_ error:(NSError* _Nullable* _Nullable)error;
/**
 * Lock locks a copy of the key.
 */
- (CryptoKey* _Nullable)lock:(NSData* _Nullable)passphrase error:(NSError* _Nullable* _Nullable)error;
/**
 * PrintFingerprints is a debug helper function that prints the key and subkey fingerprints.
 */
- (void)printFingerprints;
- (NSData* _Nullable)serialize:(NSError* _Nullable* _Nullable)error;
/**
 * ToPublic returns the corresponding public key of the given private key.
 */
- (CryptoKey* _Nullable)toPublic:(NSError* _Nullable* _Nullable)error;
/**
 * Unlock unlocks a copy of the key.
 */
- (CryptoKey* _Nullable)unlock:(NSData* _Nullable)passphrase error:(NSError* _Nullable* _Nullable)error;
@end

/**
 * KeyRing contains multiple private and public keys.
 */
@interface CryptoKeyRing : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
/**
 * NewKeyRing creates a new KeyRing, empty if key is nil.
 */
- (nullable instancetype)init:(CryptoKey* _Nullable)key;
/**
 * FirstKeyID as obtained from API to match salt
 */
@property (nonatomic) NSString* _Nonnull firstKeyID;
/**
 * AddKey adds the given key to the keyring.
 */
- (BOOL)addKey:(CryptoKey* _Nullable)key error:(NSError* _Nullable* _Nullable)error;
/**
 * CanEncrypt returns true if any of the keys in the keyring can be used for encryption.
 */
- (BOOL)canEncrypt;
/**
 * CanVerify returns true if any of the keys in the keyring can be used for verification.
 */
- (BOOL)canVerify;
- (void)clearPrivateParams;
/**
 * Copy creates a deep copy of the keyring.
 */
- (CryptoKeyRing* _Nullable)copy:(NSError* _Nullable* _Nullable)error;
/**
 * CountDecryptionEntities returns the number of entities in the keyring.
 */
- (long)countDecryptionEntities;
/**
 * CountEntities returns the number of entities in the keyring.
 */
- (long)countEntities;
/**
 * Decrypt decrypts encrypted string using pgp keys, returning a PlainMessage
* message    : The encrypted input as a PGPMessage
* verifyKey  : Public key for signature verification (optional)
* verifyTime : Time at verification (necessary only if verifyKey is not nil)

When verifyKey is not provided, then verifyTime should be zero, and
signature verification will be ignored.
 */
- (CryptoPlainMessage* _Nullable)decrypt:(CryptoPGPMessage* _Nullable)message verifyKey:(CryptoKeyRing* _Nullable)verifyKey verifyTime:(int64_t)verifyTime error:(NSError* _Nullable* _Nullable)error;
- (CryptoPlainMessage* _Nullable)decryptAttachment:(CryptoPGPSplitMessage* _Nullable)message error:(NSError* _Nullable* _Nullable)error;
/**
 * DecryptMIMEMessage decrypts a MIME message.
 */
- (void)decryptMIMEMessage:(CryptoPGPMessage* _Nullable)message verifyKey:(CryptoKeyRing* _Nullable)verifyKey callbacks:(id<CryptoMIMECallbacks> _Nullable)callbacks verifyTime:(int64_t)verifyTime;
/**
 * DecryptSessionKey returns the decrypted session key from one or multiple binary encrypted session key packets.
 */
- (CryptoSessionKey* _Nullable)decryptSessionKey:(NSData* _Nullable)keyPacket error:(NSError* _Nullable* _Nullable)error;
/**
 * DecryptSplitStream is used to decrypt a split pgp message as a Reader.
It takes a key packet and a reader for the data packet
and returns a PlainMessageReader for the plaintext data.
If verifyKeyRing is not nil, PlainMessageReader.VerifySignature() will
verify the embedded signature with the given key ring and verification time.
 */
- (CryptoPlainMessageReader* _Nullable)decryptSplitStream:(NSData* _Nullable)keypacket dataPacketReader:(id<CryptoReader> _Nullable)dataPacketReader verifyKeyRing:(CryptoKeyRing* _Nullable)verifyKeyRing verifyTime:(int64_t)verifyTime error:(NSError* _Nullable* _Nullable)error;
/**
 * DecryptStream is used to decrypt a pgp message as a Reader.
It takes a reader for the message data
and returns a PlainMessageReader for the plaintext data.
If verifyKeyRing is not nil, PlainMessageReader.VerifySignature() will
verify the embedded signature with the given key ring and verification time.
 */
- (CryptoPlainMessageReader* _Nullable)decryptStream:(id<CryptoReader> _Nullable)message verifyKeyRing:(CryptoKeyRing* _Nullable)verifyKeyRing verifyTime:(int64_t)verifyTime error:(NSError* _Nullable* _Nullable)error;
/**
 * Encrypt encrypts a PlainMessage, outputs a PGPMessage.
If an unlocked private key is also provided it will also sign the message.
* message    : The plaintext input as a PlainMessage.
* privateKey : (optional) an unlocked private keyring to include signature in the message.
 */
- (CryptoPGPMessage* _Nullable)encrypt:(CryptoPlainMessage* _Nullable)message privateKey:(CryptoKeyRing* _Nullable)privateKey error:(NSError* _Nullable* _Nullable)error;
- (CryptoPGPSplitMessage* _Nullable)encryptAttachment:(CryptoPlainMessage* _Nullable)message filename:(NSString* _Nullable)filename error:(NSError* _Nullable* _Nullable)error;
/**
 * EncryptSessionKey encrypts the session key with the unarmored
publicKey and returns a binary public-key encrypted session key packet.
 */
- (NSData* _Nullable)encryptSessionKey:(CryptoSessionKey* _Nullable)sk error:(NSError* _Nullable* _Nullable)error;
/**
 * EncryptSplitStream is used to encrypt data as a stream.
It takes a writer for the Symmetrically Encrypted Data Packet
(https://datatracker.ietf.org/doc/html/rfc4880#section-5.7)
and returns a writer for the plaintext data and the key packet.
If signKeyRing is not nil, it is used to do an embedded signature.
 */
- (CryptoEncryptSplitResult* _Nullable)encryptSplitStream:(id<CryptoWriter> _Nullable)dataPacketWriter plainMessageMetadata:(CryptoPlainMessageMetadata* _Nullable)plainMessageMetadata signKeyRing:(CryptoKeyRing* _Nullable)signKeyRing error:(NSError* _Nullable* _Nullable)error;
/**
 * EncryptSplitStreamWithCompression is used to encrypt data as a stream.
It takes a writer for the Symmetrically Encrypted Data Packet
(https://datatracker.ietf.org/doc/html/rfc4880#section-5.7)
and returns a writer for the plaintext data and the key packet.
If signKeyRing is not nil, it is used to do an embedded signature.
 */
- (CryptoEncryptSplitResult* _Nullable)encryptSplitStreamWithCompression:(id<CryptoWriter> _Nullable)dataPacketWriter plainMessageMetadata:(CryptoPlainMessageMetadata* _Nullable)plainMessageMetadata signKeyRing:(CryptoKeyRing* _Nullable)signKeyRing error:(NSError* _Nullable* _Nullable)error;
/**
 * EncryptStream is used to encrypt data as a Writer.
It takes a writer for the encrypted data and returns a WriteCloser for the plaintext data
If signKeyRing is not nil, it is used to do an embedded signature.
 */
- (id<CryptoWriteCloser> _Nullable)encryptStream:(id<CryptoWriter> _Nullable)pgpMessageWriter plainMessageMetadata:(CryptoPlainMessageMetadata* _Nullable)plainMessageMetadata signKeyRing:(CryptoKeyRing* _Nullable)signKeyRing error:(NSError* _Nullable* _Nullable)error;
/**
 * EncryptStreamWithCompression is used to encrypt data as a Writer.
The plaintext data is compressed before being encrypted.
It takes a writer for the encrypted data and returns a WriteCloser for the plaintext data
If signKeyRing is not nil, it is used to do an embedded signature.
 */
- (id<CryptoWriteCloser> _Nullable)encryptStreamWithCompression:(id<CryptoWriter> _Nullable)pgpMessageWriter plainMessageMetadata:(CryptoPlainMessageMetadata* _Nullable)plainMessageMetadata signKeyRing:(CryptoKeyRing* _Nullable)signKeyRing error:(NSError* _Nullable* _Nullable)error;
/**
 * EncryptWithCompression encrypts with compression support a PlainMessage to PGPMessage using public/private keys.
* message : The plain data as a PlainMessage.
* privateKey : (optional) an unlocked private keyring to include signature in the message.
* output  : The encrypted data as PGPMessage.
 */
- (CryptoPGPMessage* _Nullable)encryptWithCompression:(CryptoPlainMessage* _Nullable)message privateKey:(CryptoKeyRing* _Nullable)privateKey error:(NSError* _Nullable* _Nullable)error;
/**
 * FirstKey returns a KeyRing with only the first key of the original one.
 */
- (CryptoKeyRing* _Nullable)firstKey:(NSError* _Nullable* _Nullable)error;
// skipped method KeyRing.GetIdentities with unsupported parameter or return types

/**
 * GetKey returns the n-th openpgp key contained in this KeyRing.
 */
- (CryptoKey* _Nullable)getKey:(long)n error:(NSError* _Nullable* _Nullable)error;
// skipped method KeyRing.GetKeyIDs with unsupported parameter or return types

// skipped method KeyRing.GetKeys with unsupported parameter or return types

/**
 * GetVerifiedSignatureTimestamp verifies a PlainMessage with a detached PGPSignature
returns the creation time of the signature if it succeeds
and returns a SignatureVerificationError if fails.
 */
- (BOOL)getVerifiedSignatureTimestamp:(CryptoPlainMessage* _Nullable)message signature:(CryptoPGPSignature* _Nullable)signature verifyTime:(int64_t)verifyTime ret0_:(int64_t* _Nullable)ret0_ error:(NSError* _Nullable* _Nullable)error;
/**
 * GetVerifiedSignatureTimestampWithContext verifies a PlainMessage with a detached PGPSignature
returns the creation time of the signature if it succeeds
and returns a SignatureVerificationError if fails.
If a context is provided, it verifies that the signature is valid in the given context, using
the signature notation with name the name set in `constants.SignatureContextName`.
 */
- (BOOL)getVerifiedSignatureTimestampWithContext:(CryptoPlainMessage* _Nullable)message signature:(CryptoPGPSignature* _Nullable)signature verifyTime:(int64_t)verifyTime verificationContext:(CryptoVerificationContext* _Nullable)verificationContext ret0_:(int64_t* _Nullable)ret0_ error:(NSError* _Nullable* _Nullable)error;
- (CryptoAttachmentProcessor* _Nullable)newLowMemoryAttachmentProcessor:(long)estimatedSize filename:(NSString* _Nullable)filename error:(NSError* _Nullable* _Nullable)error;
- (CryptoManualAttachmentProcessor* _Nullable)newManualAttachmentProcessor:(long)estimatedSize filename:(NSString* _Nullable)filename dataBuffer:(NSData* _Nullable)dataBuffer error:(NSError* _Nullable* _Nullable)error;
/**
 * SignDetached generates and returns a PGPSignature for a given PlainMessage.
 */
- (CryptoPGPSignature* _Nullable)signDetached:(CryptoPlainMessage* _Nullable)message error:(NSError* _Nullable* _Nullable)error;
/**
 * SignDetachedEncrypted generates and returns a PGPMessage
containing an encrypted detached signature for a given PlainMessage.
 */
- (CryptoPGPMessage* _Nullable)signDetachedEncrypted:(CryptoPlainMessage* _Nullable)message encryptionKeyRing:(CryptoKeyRing* _Nullable)encryptionKeyRing error:(NSError* _Nullable* _Nullable)error;
/**
 * SignDetachedEncryptedStream generates and returns a PGPMessage
containing an encrypted detached signature for a given message Reader.
 */
- (CryptoPGPMessage* _Nullable)signDetachedEncryptedStream:(id<CryptoReader> _Nullable)message encryptionKeyRing:(CryptoKeyRing* _Nullable)encryptionKeyRing error:(NSError* _Nullable* _Nullable)error;
/**
 * SignDetachedStream generates and returns a PGPSignature for a given message Reader.
 */
- (CryptoPGPSignature* _Nullable)signDetachedStream:(id<CryptoReader> _Nullable)message error:(NSError* _Nullable* _Nullable)error;
/**
 * SignDetachedWithContext generates and returns a PGPSignature for a given PlainMessage.
If a context is provided, it is added to the signature as notation data
with the name set in `constants.SignatureContextName`.
 */
- (CryptoPGPSignature* _Nullable)signDetachedWithContext:(CryptoPlainMessage* _Nullable)message context:(CryptoSigningContext* _Nullable)context error:(NSError* _Nullable* _Nullable)error;
/**
 * VerifyDetached verifies a PlainMessage with a detached PGPSignature
and returns a SignatureVerificationError if fails.
 */
- (BOOL)verifyDetached:(CryptoPlainMessage* _Nullable)message signature:(CryptoPGPSignature* _Nullable)signature verifyTime:(int64_t)verifyTime error:(NSError* _Nullable* _Nullable)error;
/**
 * VerifyDetachedEncrypted verifies a PlainMessage
with a PGPMessage containing an encrypted detached signature
and returns a SignatureVerificationError if fails.
 */
- (BOOL)verifyDetachedEncrypted:(CryptoPlainMessage* _Nullable)message encryptedSignature:(CryptoPGPMessage* _Nullable)encryptedSignature decryptionKeyRing:(CryptoKeyRing* _Nullable)decryptionKeyRing verifyTime:(int64_t)verifyTime error:(NSError* _Nullable* _Nullable)error;
/**
 * VerifyDetachedEncryptedStream verifies a PlainMessage
with a PGPMessage containing an encrypted detached signature
and returns a SignatureVerificationError if fails.
 */
- (BOOL)verifyDetachedEncryptedStream:(id<CryptoReader> _Nullable)message encryptedSignature:(CryptoPGPMessage* _Nullable)encryptedSignature decryptionKeyRing:(CryptoKeyRing* _Nullable)decryptionKeyRing verifyTime:(int64_t)verifyTime error:(NSError* _Nullable* _Nullable)error;
/**
 * VerifyDetachedStream verifies a message reader with a detached PGPSignature
and returns a SignatureVerificationError if fails.
 */
- (BOOL)verifyDetachedStream:(id<CryptoReader> _Nullable)message signature:(CryptoPGPSignature* _Nullable)signature verifyTime:(int64_t)verifyTime error:(NSError* _Nullable* _Nullable)error;
/**
 * VerifyDetachedStreamWithContext verifies a message reader with a detached PGPSignature
and returns a SignatureVerificationError if fails.
If a context is provided, it verifies that the signature is valid in the given context, using
the signature notations.
 */
- (BOOL)verifyDetachedStreamWithContext:(id<CryptoReader> _Nullable)message signature:(CryptoPGPSignature* _Nullable)signature verifyTime:(int64_t)verifyTime verificationContext:(CryptoVerificationContext* _Nullable)verificationContext error:(NSError* _Nullable* _Nullable)error;
/**
 * VerifyDetachedWithContext verifies a PlainMessage with a detached PGPSignature
and returns a SignatureVerificationError if fails.
If a context is provided, it verifies that the signature is valid in the given context, using
the signature notation with name the name set in `constants.SignatureContextName`.
 */
- (BOOL)verifyDetachedWithContext:(CryptoPlainMessage* _Nullable)message signature:(CryptoPGPSignature* _Nullable)signature verifyTime:(int64_t)verifyTime verificationContext:(CryptoVerificationContext* _Nullable)verificationContext error:(NSError* _Nullable* _Nullable)error;
@end

/**
 * ManualAttachmentProcessor keeps track of the progress of encrypting an attachment
(optimized for encrypting large files).
With this processor, the caller has to first allocate
a buffer large enough to hold the whole data packet.
 */
@interface CryptoManualAttachmentProcessor : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
/**
 * Finish tells the processor to finalize encryption.
 */
- (BOOL)finish:(NSError* _Nullable* _Nullable)error;
/**
 * GetDataLength returns the number of bytes in the DataPacket.
This should be called only after Finish() has been called.
 */
- (long)getDataLength;
/**
 * GetKeyPacket returns the key packet for the attachment.
This should be called only after Finish() has been called.
 */
- (NSData* _Nullable)getKeyPacket;
/**
 * Process writes attachment data to be encrypted.
 */
- (BOOL)process:(NSData* _Nullable)plainData error:(NSError* _Nullable* _Nullable)error;
@end

/**
 * PGPMessage stores a PGP-encrypted message.
 */
@interface CryptoPGPMessage : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
/**
 * NewPGPMessage generates a new PGPMessage from the unarmored binary data.
 */
- (nullable instancetype)init:(NSData* _Nullable)data;
/**
 * NewPGPMessageFromArmored generates a new PGPMessage from an armored string ready for decryption.
 */
- (nullable instancetype)initFromArmored:(NSString* _Nullable)armored;
/**
 * The content of the message
 */
@property (nonatomic) NSData* _Nullable data;
/**
 * GetArmored returns the armored message as a string.
 */
- (NSString* _Nonnull)getArmored:(NSError* _Nullable* _Nullable)error;
/**
 * GetArmoredWithCustomHeaders returns the armored message as a string, with
the given headers. Empty parameters are omitted from the headers.
 */
- (NSString* _Nonnull)getArmoredWithCustomHeaders:(NSString* _Nullable)comment version:(NSString* _Nullable)version error:(NSError* _Nullable* _Nullable)error;
/**
 * GetBinary returns the unarmored binary content of the message as a []byte.
 */
- (NSData* _Nullable)getBinary;
// skipped method PGPMessage.GetEncryptionKeyIDs with unsupported parameter or return types

// skipped method PGPMessage.GetHexEncryptionKeyIDs with unsupported parameter or return types

// skipped method PGPMessage.GetHexSignatureKeyIDs with unsupported parameter or return types

// skipped method PGPMessage.GetSignatureKeyIDs with unsupported parameter or return types

// skipped method PGPMessage.NewReader with unsupported parameter or return types

/**
 * SeparateKeyAndData splits the message into key and data packet(s).
Parameters are for backwards compatibility and are unused.
Deprecated: use SplitMessage().
 */
- (CryptoPGPSplitMessage* _Nullable)separateKeyAndData:(long)p0 p1:(long)p1 error:(NSError* _Nullable* _Nullable)error;
/**
 * SplitMessage splits the message into key and data packet(s).
Parameters are for backwards compatibility and are unused.
 */
- (CryptoPGPSplitMessage* _Nullable)splitMessage:(NSError* _Nullable* _Nullable)error;
@end

/**
 * PGPSignature stores a PGP-encoded detached signature.
 */
@interface CryptoPGPSignature : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
/**
 * NewPGPSignature generates a new PGPSignature from the unarmored binary data.
 */
- (nullable instancetype)init:(NSData* _Nullable)data;
/**
 * NewPGPSignatureFromArmored generates a new PGPSignature from the armored
string ready for verification.
 */
- (nullable instancetype)initFromArmored:(NSString* _Nullable)armored;
/**
 * The content of the signature
 */
@property (nonatomic) NSData* _Nullable data;
/**
 * GetArmored returns the armored signature as a string.
 */
- (NSString* _Nonnull)getArmored:(NSError* _Nullable* _Nullable)error;
/**
 * GetBinary returns the unarmored binary content of the signature as a []byte.
 */
- (NSData* _Nullable)getBinary;
// skipped method PGPSignature.GetHexSignatureKeyIDs with unsupported parameter or return types

// skipped method PGPSignature.GetSignatureKeyIDs with unsupported parameter or return types

@end

/**
 * PGPSplitMessage contains a separate session key packet and symmetrically
encrypted data packet.
 */
@interface CryptoPGPSplitMessage : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
/**
 * NewPGPSplitMessage generates a new PGPSplitMessage from the binary unarmored keypacket,
datapacket, and encryption algorithm.
 */
- (nullable instancetype)init:(NSData* _Nullable)keyPacket dataPacket:(NSData* _Nullable)dataPacket;
/**
 * NewPGPSplitMessageFromArmored generates a new PGPSplitMessage by splitting an armored message into its
session key packet and symmetrically encrypted data packet.
 */
- (nullable instancetype)initFromArmored:(NSString* _Nullable)encrypted;
@property (nonatomic) NSData* _Nullable dataPacket;
@property (nonatomic) NSData* _Nullable keyPacket;
/**
 * GetArmored returns the armored message as a string, with joined data and key
packets.
 */
- (NSString* _Nonnull)getArmored:(NSError* _Nullable* _Nullable)error;
/**
 * GetBinary returns the unarmored binary joined packets as a []byte.
 */
- (NSData* _Nullable)getBinary;
/**
 * GetBinaryDataPacket returns the unarmored binary datapacket as a []byte.
 */
- (NSData* _Nullable)getBinaryDataPacket;
/**
 * GetBinaryKeyPacket returns the unarmored binary keypacket as a []byte.
 */
- (NSData* _Nullable)getBinaryKeyPacket;
/**
 * GetPGPMessage joins asymmetric session key packet with the symmetric data
packet to obtain a PGP message.
 */
- (CryptoPGPMessage* _Nullable)getPGPMessage;
@end

/**
 * PlainMessage stores a plain text / unencrypted message.
 */
@interface CryptoPlainMessage : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
/**
 * NewPlainMessage generates a new binary PlainMessage ready for encryption,
signature, or verification from the unencrypted binary data.
This will encrypt the message with the binary flag and preserve the file as is.
 */
- (nullable instancetype)init:(NSData* _Nullable)data;
// skipped constructor PlainMessage.NewPlainMessageFromFile with unsupported parameter or return types

/**
 * NewPlainMessageFromString generates a new text PlainMessage,
ready for encryption, signature, or verification from an unencrypted string.
This will encrypt the message with the text flag, canonicalize the line endings
(i.e. set all of them to \r\n) and strip the trailing spaces for each line.
This allows seamless conversion to clear text signed messages (see RFC 4880 5.2.1 and 7.1).
 */
- (nullable instancetype)initFromString:(NSString* _Nullable)text;
/**
 * The content of the message
 */
@property (nonatomic) NSData* _Nullable data;
/**
 * If the content is text or binary
 */
@property (nonatomic) BOOL textType;
// skipped field PlainMessage.Time with unsupported type: uint32

/**
 * The encrypted message's filename
 */
@property (nonatomic) NSString* _Nonnull filename;
/**
 * GetBase64 returns the base-64 encoded binary content of the message as a
string.
 */
- (NSString* _Nonnull)getBase64;
/**
 * GetBinary returns the binary content of the message as a []byte.
 */
- (NSData* _Nullable)getBinary;
/**
 * GetFilename returns the file name of the message as a string.
 */
- (NSString* _Nonnull)getFilename;
/**
 * GetString returns the content of the message as a string.
 */
- (NSString* _Nonnull)getString;
// skipped method PlainMessage.GetTime with unsupported parameter or return types

/**
 * IsBinary returns whether the message is a binary message.
 */
- (BOOL)isBinary;
/**
 * IsText returns whether the message is a text message.
 */
- (BOOL)isText;
// skipped method PlainMessage.NewReader with unsupported parameter or return types

@end

@interface CryptoPlainMessageMetadata : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nullable instancetype)init:(BOOL)isBinary filename:(NSString* _Nullable)filename modTime:(int64_t)modTime;
@property (nonatomic) BOOL isBinary;
@property (nonatomic) NSString* _Nonnull filename;
@property (nonatomic) int64_t modTime;
@end

/**
 * PlainMessageReader is used to wrap the data of the decrypted plain message.
It can be used to read the decrypted data and verify the embedded signature.
 */
@interface CryptoPlainMessageReader : NSObject <goSeqRefInterface, CryptoReader> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
/**
 * GetMetadata returns the metadata of the decrypted message.
 */
- (CryptoPlainMessageMetadata* _Nullable)getMetadata;
/**
 * Read is used to access the message decrypted data.
Makes PlainMessageReader implement the Reader interface.
 */
- (BOOL)read:(NSData* _Nullable)b n:(long* _Nullable)n error:(NSError* _Nullable* _Nullable)error;
/**
 * VerifySignature is used to verify that the signature is valid.
This method needs to be called once all the data has been read.
It will return an error if the signature is invalid
or if the message hasn't been read entirely.
 */
- (BOOL)verifySignature:(NSError* _Nullable* _Nullable)error;
@end

/**
 * SessionKey stores a decrypted session key.
 */
@interface CryptoSessionKey : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nullable instancetype)initFromToken:(NSData* _Nullable)token algo:(NSString* _Nullable)algo;
/**
 * The decrypted binary session key.
 */
@property (nonatomic) NSData* _Nullable key;
/**
 * The symmetric encryption algorithm used with this key.
 */
@property (nonatomic) NSString* _Nonnull algo;
- (BOOL)clear;
/**
 * Decrypt decrypts pgp data packets using directly a session key.
* encrypted: PGPMessage.
* output: PlainMessage.
 */
- (CryptoPlainMessage* _Nullable)decrypt:(NSData* _Nullable)dataPacket error:(NSError* _Nullable* _Nullable)error;
/**
 * DecryptAndVerify decrypts pgp data packets using directly a session key and verifies embedded signatures.
* encrypted: PGPMessage.
* verifyKeyRing: KeyRing with verification public keys
* verifyTime: when should the signature be valid, as timestamp. If 0 time verification is disabled.
* output: PlainMessage.
 */
- (CryptoPlainMessage* _Nullable)decryptAndVerify:(NSData* _Nullable)dataPacket verifyKeyRing:(CryptoKeyRing* _Nullable)verifyKeyRing verifyTime:(int64_t)verifyTime error:(NSError* _Nullable* _Nullable)error;
/**
 * DecryptStream is used to decrypt a data packet as a Reader.
It takes a reader for the data packet
and returns a PlainMessageReader for the plaintext data.
If verifyKeyRing is not nil, PlainMessageReader.VerifySignature() will
verify the embedded signature with the given key ring and verification time.
 */
- (CryptoPlainMessageReader* _Nullable)decryptStream:(id<CryptoReader> _Nullable)dataPacketReader verifyKeyRing:(CryptoKeyRing* _Nullable)verifyKeyRing verifyTime:(int64_t)verifyTime error:(NSError* _Nullable* _Nullable)error;
/**
 * Encrypt encrypts a PlainMessage to PGPMessage with a SessionKey.
* message : The plain data as a PlainMessage.
* output  : The encrypted data as PGPMessage.
 */
- (NSData* _Nullable)encrypt:(CryptoPlainMessage* _Nullable)message error:(NSError* _Nullable* _Nullable)error;
/**
 * EncryptAndSign encrypts a PlainMessage to PGPMessage with a SessionKey and signs it with a Private key.
* message : The plain data as a PlainMessage.
* signKeyRing: The KeyRing to sign the message
* output  : The encrypted data as PGPMessage.
 */
- (NSData* _Nullable)encryptAndSign:(CryptoPlainMessage* _Nullable)message signKeyRing:(CryptoKeyRing* _Nullable)signKeyRing error:(NSError* _Nullable* _Nullable)error;
/**
 * EncryptStream is used to encrypt data as a Writer.
It takes a writer for the encrypted data packet and returns a writer for the plaintext data.
If signKeyRing is not nil, it is used to do an embedded signature.
 */
- (id<CryptoWriteCloser> _Nullable)encryptStream:(id<CryptoWriter> _Nullable)dataPacketWriter plainMessageMetadata:(CryptoPlainMessageMetadata* _Nullable)plainMessageMetadata signKeyRing:(CryptoKeyRing* _Nullable)signKeyRing error:(NSError* _Nullable* _Nullable)error;
/**
 * EncryptStreamWithCompression is used to encrypt data as a Writer.
The plaintext data is compressed before being encrypted.
It takes a writer for the encrypted data packet and returns a writer for the plaintext data.
If signKeyRing is not nil, it is used to do an embedded signature.
 */
- (id<CryptoWriteCloser> _Nullable)encryptStreamWithCompression:(id<CryptoWriter> _Nullable)dataPacketWriter plainMessageMetadata:(CryptoPlainMessageMetadata* _Nullable)plainMessageMetadata signKeyRing:(CryptoKeyRing* _Nullable)signKeyRing error:(NSError* _Nullable* _Nullable)error;
/**
 * EncryptWithCompression encrypts with compression support a PlainMessage to PGPMessage with a SessionKey.
* message : The plain data as a PlainMessage.
* output  : The encrypted data as PGPMessage.
 */
- (NSData* _Nullable)encryptWithCompression:(CryptoPlainMessage* _Nullable)message error:(NSError* _Nullable* _Nullable)error;
/**
 * GetBase64Key returns the session key as base64 encoded string.
 */
- (NSString* _Nonnull)getBase64Key;
// skipped method SessionKey.GetCipherFunc with unsupported parameter or return types

@end

/**
 * SignatureCollector structure.
 */
@interface CryptoSignatureCollector : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
// skipped method SignatureCollector.Accept with unsupported parameter or return types

/**
 * GetSignature collected by Accept.
 */
- (NSString* _Nonnull)getSignature;
@end

/**
 * SignatureVerificationError is returned from Decrypt and VerifyDetached
functions when signature verification fails.
 */
@interface CryptoSignatureVerificationError : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
@property (nonatomic) long status;
@property (nonatomic) NSString* _Nonnull message;
/**
 * Error is the base method for all errors.
 */
- (NSString* _Nonnull)error;
@end

/**
 * SigningContext gives the context that will be
included in the signature's notation data.
 */
@interface CryptoSigningContext : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
/**
 * NewSigningContext creates a new signing context.
The value is set to the notation data.
isCritical controls whether the notation is flagged as a critical packet.
 */
- (nullable instancetype)init:(NSString* _Nullable)value isCritical:(BOOL)isCritical;
@property (nonatomic) NSString* _Nonnull value;
@property (nonatomic) BOOL isCritical;
@end

/**
 * VerificationContext gives the context that will be
used to verify the signature.
 */
@interface CryptoVerificationContext : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
/**
 * NewVerificationContext creates a new verification context.
The value is checked against the signature's notation data.
If isRequired is false, the signature is allowed to have no context set.
If requiredAfter is != 0, the signature is allowed to have no context set if it
was created before the unix time set in requiredAfter.
 */
- (nullable instancetype)init:(NSString* _Nullable)value isRequired:(BOOL)isRequired requiredAfter:(int64_t)requiredAfter;
@property (nonatomic) NSString* _Nonnull value;
@property (nonatomic) BOOL isRequired;
@property (nonatomic) int64_t requiredAfter;
@end

/**
 * DecryptMessageWithPassword decrypts password protected pgp binary messages.
* encrypted: The encrypted data as PGPMessage.
* password: A password that will be derived into an encryption key.
* output: The decrypted data as PlainMessage.
 */
FOUNDATION_EXPORT CryptoPlainMessage* _Nullable CryptoDecryptMessageWithPassword(CryptoPGPMessage* _Nullable message, NSData* _Nullable password, NSError* _Nullable* _Nullable error);

/**
 * DecryptSessionKeyWithPassword decrypts the binary symmetrically encrypted
session key packet and returns the session key.
 */
FOUNDATION_EXPORT CryptoSessionKey* _Nullable CryptoDecryptSessionKeyWithPassword(NSData* _Nullable keyPacket, NSData* _Nullable password, NSError* _Nullable* _Nullable error);

/**
 * EncryptMessageWithPassword encrypts a PlainMessage to PGPMessage with a
SymmetricKey.
* message : The plain data as a PlainMessage.
* password: A password that will be derived into an encryption key.
* output  : The encrypted data as PGPMessage.
 */
FOUNDATION_EXPORT CryptoPGPMessage* _Nullable CryptoEncryptMessageWithPassword(CryptoPlainMessage* _Nullable message, NSData* _Nullable password, NSError* _Nullable* _Nullable error);

/**
 * EncryptSessionKeyWithPassword encrypts the session key with the password and
returns a binary symmetrically encrypted session key packet.
 */
FOUNDATION_EXPORT NSData* _Nullable CryptoEncryptSessionKeyWithPassword(CryptoSessionKey* _Nullable sk, NSData* _Nullable password, NSError* _Nullable* _Nullable error);

// skipped function FilterExpiredKeys with unsupported parameter or return types


/**
 * GenerateKey generates a key of the given keyType ("rsa" or "x25519").
If keyType is "rsa", bits is the RSA bitsize of the key.
If keyType is "x25519" bits is unused.
 */
FOUNDATION_EXPORT CryptoKey* _Nullable CryptoGenerateKey(NSString* _Nullable name, NSString* _Nullable email, NSString* _Nullable keyType, long bits, NSError* _Nullable* _Nullable error);

/**
 * GenerateRSAKeyWithPrimes generates a RSA key using the given primes.
 */
FOUNDATION_EXPORT CryptoKey* _Nullable CryptoGenerateRSAKeyWithPrimes(NSString* _Nullable name, NSString* _Nullable email, long bits, NSData* _Nullable primeone, NSData* _Nullable primetwo, NSData* _Nullable primethree, NSData* _Nullable primefour, NSError* _Nullable* _Nullable error);

/**
 * GenerateSessionKey generates a random key for the default cipher.
 */
FOUNDATION_EXPORT CryptoSessionKey* _Nullable CryptoGenerateSessionKey(NSError* _Nullable* _Nullable error);

/**
 * GenerateSessionKeyAlgo generates a random key of the correct length for the
specified algorithm.
 */
FOUNDATION_EXPORT CryptoSessionKey* _Nullable CryptoGenerateSessionKeyAlgo(NSString* _Nullable algo, NSError* _Nullable* _Nullable error);

// skipped function GetTime with unsupported parameter or return types


/**
 * GetUnixTime gets latest cached time.
 */
FOUNDATION_EXPORT int64_t CryptoGetUnixTime(void);

/**
 * IsPGPMessage checks if data if has armored PGP message format.
 */
FOUNDATION_EXPORT BOOL CryptoIsPGPMessage(NSString* _Nullable data);

/**
 * NewClearTextMessage generates a new ClearTextMessage from data and
signature.
 */
FOUNDATION_EXPORT CryptoClearTextMessage* _Nullable CryptoNewClearTextMessage(NSData* _Nullable data, NSData* _Nullable signature);

/**
 * NewClearTextMessageFromArmored returns the message body and unarmored
signature from a clearsigned message.
 */
FOUNDATION_EXPORT CryptoClearTextMessage* _Nullable CryptoNewClearTextMessageFromArmored(NSString* _Nullable signedMessage, NSError* _Nullable* _Nullable error);

/**
 * NewKey creates a new key from the first key in the unarmored binary data.
 */
FOUNDATION_EXPORT CryptoKey* _Nullable CryptoNewKey(NSData* _Nullable binKeys, NSError* _Nullable* _Nullable error);

/**
 * NewKeyFromArmored creates a new key from the first key in an armored string.
 */
FOUNDATION_EXPORT CryptoKey* _Nullable CryptoNewKeyFromArmored(NSString* _Nullable armored, NSError* _Nullable* _Nullable error);

// skipped function NewKeyFromArmoredReader with unsupported parameter or return types


// skipped function NewKeyFromEntity with unsupported parameter or return types


// skipped function NewKeyFromReader with unsupported parameter or return types


/**
 * NewKeyRing creates a new KeyRing, empty if key is nil.
 */
FOUNDATION_EXPORT CryptoKeyRing* _Nullable CryptoNewKeyRing(CryptoKey* _Nullable key, NSError* _Nullable* _Nullable error);

/**
 * NewPGPMessage generates a new PGPMessage from the unarmored binary data.
 */
FOUNDATION_EXPORT CryptoPGPMessage* _Nullable CryptoNewPGPMessage(NSData* _Nullable data);

/**
 * NewPGPMessageFromArmored generates a new PGPMessage from an armored string ready for decryption.
 */
FOUNDATION_EXPORT CryptoPGPMessage* _Nullable CryptoNewPGPMessageFromArmored(NSString* _Nullable armored, NSError* _Nullable* _Nullable error);

/**
 * NewPGPSignature generates a new PGPSignature from the unarmored binary data.
 */
FOUNDATION_EXPORT CryptoPGPSignature* _Nullable CryptoNewPGPSignature(NSData* _Nullable data);

/**
 * NewPGPSignatureFromArmored generates a new PGPSignature from the armored
string ready for verification.
 */
FOUNDATION_EXPORT CryptoPGPSignature* _Nullable CryptoNewPGPSignatureFromArmored(NSString* _Nullable armored, NSError* _Nullable* _Nullable error);

/**
 * NewPGPSplitMessage generates a new PGPSplitMessage from the binary unarmored keypacket,
datapacket, and encryption algorithm.
 */
FOUNDATION_EXPORT CryptoPGPSplitMessage* _Nullable CryptoNewPGPSplitMessage(NSData* _Nullable keyPacket, NSData* _Nullable dataPacket);

/**
 * NewPGPSplitMessageFromArmored generates a new PGPSplitMessage by splitting an armored message into its
session key packet and symmetrically encrypted data packet.
 */
FOUNDATION_EXPORT CryptoPGPSplitMessage* _Nullable CryptoNewPGPSplitMessageFromArmored(NSString* _Nullable encrypted, NSError* _Nullable* _Nullable error);

/**
 * NewPlainMessage generates a new binary PlainMessage ready for encryption,
signature, or verification from the unencrypted binary data.
This will encrypt the message with the binary flag and preserve the file as is.
 */
FOUNDATION_EXPORT CryptoPlainMessage* _Nullable CryptoNewPlainMessage(NSData* _Nullable data);

// skipped function NewPlainMessageFromFile with unsupported parameter or return types


/**
 * NewPlainMessageFromString generates a new text PlainMessage,
ready for encryption, signature, or verification from an unencrypted string.
This will encrypt the message with the text flag, canonicalize the line endings
(i.e. set all of them to \r\n) and strip the trailing spaces for each line.
This allows seamless conversion to clear text signed messages (see RFC 4880 5.2.1 and 7.1).
 */
FOUNDATION_EXPORT CryptoPlainMessage* _Nullable CryptoNewPlainMessageFromString(NSString* _Nullable text);

FOUNDATION_EXPORT CryptoPlainMessageMetadata* _Nullable CryptoNewPlainMessageMetadata(BOOL isBinary, NSString* _Nullable filename, int64_t modTime);

FOUNDATION_EXPORT CryptoSessionKey* _Nullable CryptoNewSessionKeyFromToken(NSData* _Nullable token, NSString* _Nullable algo);

/**
 * NewSigningContext creates a new signing context.
The value is set to the notation data.
isCritical controls whether the notation is flagged as a critical packet.
 */
FOUNDATION_EXPORT CryptoSigningContext* _Nullable CryptoNewSigningContext(NSString* _Nullable value, BOOL isCritical);

/**
 * NewVerificationContext creates a new verification context.
The value is checked against the signature's notation data.
If isRequired is false, the signature is allowed to have no context set.
If requiredAfter is != 0, the signature is allowed to have no context set if it
was created before the unix time set in requiredAfter.
 */
FOUNDATION_EXPORT CryptoVerificationContext* _Nullable CryptoNewVerificationContext(NSString* _Nullable value, BOOL isRequired, int64_t requiredAfter);

/**
 * RandomToken generates a random token with the specified key size.
 */
FOUNDATION_EXPORT NSData* _Nullable CryptoRandomToken(long size, NSError* _Nullable* _Nullable error);

/**
 * SetKeyGenerationOffset updates the offset when generating keys.
 */
FOUNDATION_EXPORT void CryptoSetKeyGenerationOffset(int64_t offset);

/**
 * UpdateTime updates cached time.
 */
FOUNDATION_EXPORT void CryptoUpdateTime(int64_t newTime);

@class CryptoMIMECallbacks;

@class CryptoReader;

@class CryptoWriteCloser;

@class CryptoWriter;

/**
 * MIMECallbacks defines callback methods to process a MIME message.
 */
@interface CryptoMIMECallbacks : NSObject <goSeqRefInterface, CryptoMIMECallbacks> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (void)onAttachment:(NSString* _Nullable)headers data:(NSData* _Nullable)data;
- (void)onBody:(NSString* _Nullable)body mimetype:(NSString* _Nullable)mimetype;
/**
 * Encrypted headers can be in an attachment and thus be placed at the end of the mime structure.
 */
- (void)onEncryptedHeaders:(NSString* _Nullable)headers;
- (void)onError:(NSError* _Nullable)err;
- (void)onVerified:(long)verified;
@end

@interface CryptoReader : NSObject <goSeqRefInterface, CryptoReader> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (BOOL)read:(NSData* _Nullable)b n:(long* _Nullable)n error:(NSError* _Nullable* _Nullable)error;
@end

@interface CryptoWriteCloser : NSObject <goSeqRefInterface, CryptoWriteCloser> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (BOOL)close:(NSError* _Nullable* _Nullable)error;
- (BOOL)write:(NSData* _Nullable)b n:(long* _Nullable)n error:(NSError* _Nullable* _Nullable)error;
@end

@interface CryptoWriter : NSObject <goSeqRefInterface, CryptoWriter> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (BOOL)write:(NSData* _Nullable)b n:(long* _Nullable)n error:(NSError* _Nullable* _Nullable)error;
@end

#endif
